---
title: '0xio Bridge'
description: 'Secure, private, and intent-based cross-chain interoperability.'
icon: 'bridge'
---

# Overview

The **0xio Bridge** is a next-generation interoperability protocol designed to connect **Octra** with **EVM** (Ethereum, Arbitrum, Optimism) and **Solana** chains. unlike traditional lock-and-mint bridges, 0xio utilizes an **Intent-Based Architecture** powered by a decentralized network of Solvers.

## Why 0xio Bridge?

### 1. Privacy-First
Leveraging Octra's **Fully Homomorphic Encryption (FHE)**, cross-chain intents are encrypted locally on the user's device. Solvers execute these intents without ever seeing the raw transaction details until necessary, ensuring protection against front-running (MEV) and preserving user financial privacy.

### 2. Instant Finality
Traditional bridges rely on slow consensus verification. 0xio Solvers take on the risk of finality in exchange for a fee, providing users with **near-instant** transfers. As soon as a Solver verifies your deposit, they release funds on the destination chain immediately.

### 3. Unified Liquidity
By using **0xio-oracle** and a constant-product AMM model for pricing, we ensure deep liquidity and fair rates. Users don't need to worry about fragmented liquidity pools; the protocol routes optimally.

---

## How It Works

The bridge operates on a **Fetch-Verify-Execute** loop:

1.  **Intent Creation**: User signs an intent (e.g., "Swap 100 USDC on Eth to OCT on Octra").
2.  **Solver Pickup**: Solvers (taking the role of Market Makers) detect this intent via the **0xio-indexer**.
3.  **Execution**: The winning Solver fulfills the request on the destination chain using their own liquidity.
4.  **Settlement**: The **0xio-oracle** verifies the execution and releases the user's original deposit to the Solver.

---

## Architecture Components

The 0xio Bridge is composed of three core microservices working in unison.

<CardGroup cols={3}>
  <Card title="Solver Engine" icon="microchip" href="#the-solver-engine">
    The execution engine that fulfills user intents across chains using MPC wallets.
  </Card>
  <Card title="Indexer" icon="database" href="#the-indexer">
    Stateless tracking service that indexes intents and monitors transaction status.
  </Card>
  <Card title="Oracle" icon="scale-balanced" href="#the-oracle">
    Decentralized pricing and security module that verifies cross-chain state.
  </Card>
</CardGroup>

---

# The Solver Engine

The **Solver** is the beating heart of the 0xio Bridge. Unlike traditional bridges that rely on static smart contracts to lock and mint assets, the 0xio Bridge uses an **Intent-Based Architecture** powered by off-chain Solvers.

## What is a Solver?

Think of a Solver as a specialized, automated market maker. When you request a bridge transfer (an "Intent"), you aren't just sending tokens to a contract; you are broadcasting a request to the network: *"I have 100 OCT, and I want 100 USDC on Ethereum."*

The Solver detects this request, verifies you've paid, and then uses its own liquidity to instantly release the funds to you on the destination chain.

## How It Works

### 1. Privacy First (ECIES)
Your privacy is paramount. When you initiate a transfer, the destination of your funds is **never revealed in plaintext** on the source chain.
*   **Encryption:** Your intent (e.g., "Send to 0x123... on Ethereum") is encrypted using **ECIES (Secp256k1)**.
*   **Delivery:**
    *   **EVM:** The encrypted payload is passed directly to the **BridgeVault** contract.
    *   **Solana:** It is attached as a **Memo instruction** to the transfer transaction.
    *   **Octra:** It is embedded as the encrypted **Transaction Message**.
*   **On-Chain Anonymity:** To the outside world, it looks like you simply sent tokens to a privacy pool. Only the Solver can decrypt your instructions.

### 2. Multi-Party Computation (MPC)
To ensure funds are safe, the Solver doesn't rely on a single private key that could be lost or stolen. It uses **Threshold MPC**.
*   **Sharded Keys:** The key to the Solver's wallet is split into multiple pieces ("shares").
*   **Collaborative Signing:** To sign a transaction, multiple independent nodes must collaborate. No single node ever sees the full key. This mimics the security of a multisig wallet but acts as a standard single-signature wallet on-chain.

### 3. Source Verification (Security)
Before release funds, the Solver performs rigorous security checks tailored to each chain:
*   **EVM Checks:** Verifies that funds were deposited into the **BridgeVault V2** smart contract (validating event logs and sender), ensuring funds aren't just sent to an EOA.
*   **Solana Checks:** Validates transfers to the Solver's **Associated Token Account (ATA)** using balance-diffing to confirm receipt.
*   **Common Checks:** Confirms transaction finality, amount accuracy, and strict intent matching.

This prevents "spoofing" attacks where malicious actors try to trick the bridge into releasing funds for fake transactions.

## Why This Architecture?

*   **Speed:** Solvers can execute transactions in parallel, limited only by the block time of the destination chain.
*   **Cost:** By aggregating liquidity, Solvers reduce the gas costs associated with complex on-chain minting logic.
*   **Privacy:** The Intent/Solver model naturally decouples the sender from the receiver, breaking the link analysis chain used by trackers.

---

# The Indexer

The **Indexer** is the central nervous system of the 0xio Bridge. While the Solver executes transactions, the Indexer keeps track of what needs to be done.

## The "Post Office" Analogy

Imagine the Bridge as a mail delivery system.
*   **You (The User)** drop a letter (Intent) into the mailbox.
*   **The Indexer** is the post office. It sorts the mail, categorizes it (Deposit vs Withdrawal), and puts it in a "Pending" pile.
*   **The Solver** is the mail carrier. It picks up the pending mail and delivers it.

## Key Responsibilities

### 1. Intent Discovery
The Indexer listens for signals from the 0xio DEX and Wallet Extension. It enforces **Type-Safe Intents** (e.g., distinguishing `DEPOSIT_SOL` from `DEPOSIT_EVM`) to ensure that every request is routed to the correct validation logic from the moment it enters the system.

When you sign a transaction, the Indexer records the "Proof of Intent" — the transaction hash and the encrypted instructions.

### 2. State Management
A bridge transaction goes through several states:
*   **PENDING:** The user has paid, waiting for the Solver.
*   **PROCESSING:** The Solver has picked up the task.
*   **COMPLETED:** Funds have been successfully delivered.
*   **FAILED:** Something went wrong (e.g., transaction reverted).

The Indexer maintains this state in real-time, allowing the UI to show you exactly where your funds are.

### 3. Historical Record
The Indexer provides a permanent history of your bridge activity. This allows you to audit your past deposits and withdrawals, even if the user interface or browser cache is cleared.

---

# The Oracle

The **Oracle** ensures that every bridge transfer happens at a fair, transparent market price. It combines the reliability of an Automated Market Maker (AMM) with the accuracy of real-time off-chain data.

## Hybrid Pricing Engine

The 0xio Oracle uses a unique hybrid model to determine the exchange rate between Octra (OCT) and Stablecoins (USDC/USDT).

### 1. The Virtual USD Pool
Instead of fragmenting liquidity between multiple pairs (OCT/USDC and OCT/USDT), the Oracle combines all stablecoin liquidity into a single **"Virtual USD"** pool.
*   **Benefit:** This creates a deeper liquidity pool, meaning large transfers suffer less "slippage" (price change).
*   **Result:** Whether you withdraw to USDC on Ethereum or USDT on Solana, you get the same fair market rate.

### 2. Pyth Network Integration
To prevent the internal bridge price from deviating from the global market, the Oracle integrates with **Pyth Network**, a high-fidelity real-time price feed.
*   The Oracle constantly checks the global price of OCT, USDC, and USDT.
*   It adjusts the internal curve to match these external prices, ensuring you never pay a significant premium compared to centralized exchanges.

## Protection Mechanisms

### Slippage Protection
When you submit an intent, you specify a `minAmountOut` — the minimum amount of tokens you are willing to accept.
*   If the price changes unfavorably while your transaction is in flight, and the output would fall below your minimum, the Solver will **wait** or **abort** rather than executing a bad trade.

### Liquidity Guard
The Oracle continuously monitors the Solver's available funds on all chains (via the **Watcher Service**). It will never give you a quote for a swap if there isn't enough liquidity to fulfill it immediately.
